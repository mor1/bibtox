#!/usr/bin/env -S uv run --script --quiet
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "bibtexparser==2.0.0b7",
#   "yattag>=1.16.0",
#   "rich>=13.7.1",
#   "click>=8.1.8",
# ]
# ///

# Copyright (C) Richard Mortier <mort@cantab.net>
# SPDX-License-Identifier: BSD-3-Clause

"""Processes BibTeX files, sorting and outputting to HTML/BIB."""

# pyright: reportAny=false
# pyright: reportAttributeAccessIssue=false
# pyright: reportMissingParameterType=false
# pyright: reportPrivateLocalImportUsage=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownParameterType=false
# pyright: reportUnknownVariableType=false

import datetime
import json
import logging
from pathlib import Path
from typing import TextIO, override

import bibtexparser
import click
from bibtexparser import middlewares as mw
from bibtexparser.middlewares import BlockMiddleware
from rich.console import Console
from rich.logging import RichHandler
from yattag import Doc, indent

errcon = Console(stderr=True)
logging.basicConfig(
    level="INFO",
    format="%(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(console=errcon, rich_tracebacks=True)],
)
log = logging.getLogger(__name__)

DOISVC = "https://doi.org"

ABBREVIATIONS = {
    "jan": "January",
    "feb": "February",
    "mar": "March",
    "apr": "April",
    "may": "May",
    "jun": "June",
    "jul": "July",
    "aug": "August",
    "sep": "September",
    "oct": "October",
    "nov": "November",
    "dec": "December",
}

MONTHS = {
    "01": "January",
    "02": "February",
    "03": "March",
    "04": "April",
    "05": "May",
    "06": "June",
    "07": "July",
    "08": "August",
    "09": "September",
    "10": "October",
    "11": "November",
    "12": "December",
}
MONTHS.update([(MONTHS[k], k) for k in MONTHS])


def parse_date(bib: bibtexparser.model.Entry) -> tuple[str, str, str]:
    """Parse an entry date, using older `year`, `month` if no `date` provided."""

    log.debug(f"{bib}")
    date = bib.get("issue_date")
    if date:
        date = date.value
        month, year = date.split(" ")
        day = ""

    else:
        date = bib.get("date")
        if date:
            date = date.value
            year, month, *day = date.split("-") if "-" in date else date.split()
        else:
            year = bib.get("year").value
            month = bib.get("month").value if bib.get("month") else ""
            month, *day = month.split("#")

    day = " ".join(day if day else "").strip().strip('"')

    month = month.strip()
    month = ABBREVIATIONS.get(month, month)
    month = MONTHS[month] if len(month) > 2 else month

    isodate = f"{year}-{month}-{day}" if month else year
    formatted = (
        f"{day} {MONTHS[month]}, {year}"
        if day
        else f"{MONTHS[month]} {year}"
        if month
        else f"{year}"
    )
    return isodate.strip("-"), formatted, year


def htmlclean(s: str) -> str:
    """Clean up `s` for HTML output."""

    return (
        s.translate(str.maketrans("", "", "{}~"))
        .replace("--", "&ndash;")
        .replace("``", "&ldquo;")
        .replace("''", "&rdquo;")
        .replace("`", "&lsquo;")
        .replace("'", "&rsquo;")
        .replace(r"\&", "&amp;")
        .replace(r"\,", "&nbsp;")
        .replace("..", ".;")
    )


def authors(
    doc: Doc,
    bib: bibtexparser.model.Entry,
    homepages: None | dict[str, str],
) -> None:
    """Format author list as HTML."""
    authors = bib.get("author").value
    with doc.tag("span", klass="authors"):
        for i, author in enumerate(authors):
            if i == 0:
                pass
            elif i + 1 == len(authors):
                doc.text(" and ")
            else:
                doc.text(", ")

            klass = "author"
            key = f"{author.first[0]} {author.last[0]}"
            homepage = homepages.get(key) if homepages else None

            if (author.first[0], author.last[0]) == ("Richard", "Mortier"):
                klass += " highlight"

            author.first = [f"{author.first[0][0].strip()}."]
            with doc.tag("span", klass=klass):
                if homepage:
                    with doc.tag("a", href=homepage):
                        doc.text(f"{author.merge_last_name_first}")
                else:
                    doc.text(f"{author.merge_last_name_first}")


def year(doc: Doc, year: str) -> None:
    """Format `year` as HTML."""
    with doc.tag("span", klass="year"):
        doc.text(f" ({year}). ")


def title(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Format `title` as HTML."""
    title = htmlclean(bib.get("title").value)

    with doc.tag("span", klass="title"):
        doc.asis(f"&ldquo;{title}&rdquo;")
    doc.text(". ")


def venue(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Parse and format `venue` as HTML."""

    addendum = ""
    address = None
    number = None
    pages = None
    venue = None
    volume = None

    match bib.entry_type:
        case "inproceedings":
            doc.text("In ")
            venue = bib["booktitle"]
            pages = bib.get("pages")
            address = bib.get("address")

        case "article":
            doc.text("In ")
            venue = bib.get("journaltitle")
            if not venue:
                venue = bib.get("journal")

            volume = bib.get("volume")
            number = bib.get("number")
            pages = bib.get("pages")

        case "patent":
            venue = "Patent"

        case "online" | "report" | "misc":
            doc.text("In ")
            venue = bib.get("eprinttype")
            if not venue:
                venue = bib.get("institution")
            if not venue:
                venue = bib.get("publisher")

        case "inbook":
            doc.text("In ")
            venue = bib.get("volume")
            if not venue:
                venue = bib.get("booktitle")

        case "unpublished":
            venue = ""

        case "book":
            venue = ""

        case "techreport":
            venue = bib["type"]

        case _:
            venue = "UNKNOWN VENUE"

    if venue and hasattr(venue, "value"):
        venue = venue.value
    if "volume" in locals() and volume:
        addendum += f"&nbsp;{volume.value}"
    if "number" in locals() and number:
        addendum += f"({number.value})"
    if "pages" in locals() and pages:
        pages = htmlclean(pages.value)
        addendum += f" pp.&nbsp;{pages}"
    if "address" in locals() and address:
        addendum += f". {address.value}"

    with doc.tag("span", klass="venue"):
        doc.asis(f"{htmlclean(venue)}")

    if len(addendum) > 0:
        doc.asis(f"{htmlclean(addendum)}")


def publisher(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Format `publisher` as HTML."""
    publisher = bib.get("publisher")
    if publisher:
        with doc.tag("span", klass="publisher"):
            doc.text(f" ({publisher.value.strip()})")


def date(doc: Doc, date: str) -> None:
    """Format `date` as HTML."""
    with doc.tag("span", klass="date"):
        doc.asis(f"{htmlclean(date)}")
    doc.text(". ")


def note(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Format `note` as HTML."""
    note = bib.get("note")
    if note:
        with doc.tag("span", klass="note"):
            doc.asis(f"{htmlclean(note.value)}".replace("..", "."))
        if not note.value.endswith("."):
            doc.text(". ")


def doi(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Format `doi` as HTML."""
    doi = bib.get("doi")
    if doi:
        with doc.tag("span", klass="doi"):
            with doc.tag("a", href=f"{DOISVC}/{doi.value}"):
                doc.asis("doi")


def url(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Format `url` as HTML."""
    url = bib.get("url")
    log.debug(f"{url=} {bib=}")
    if url and not (bib.get("doi") and "doi.org" in url.value):
        with doc.tag("span", klass="url"):
            with doc.tag("a", href=url.value):
                doc.asis("url")


def pdf(doc: Doc, bib: bibtexparser.model.Entry) -> None:
    """Format `pdf` as HTML."""
    pdf = bib.get("pdf")
    log.debug(f"{pdf=} {bib=}")
    with doc.tag("span", klass="pdf"):
        with doc.tag("a", href=pdf.value):
            doc.asis("pdf")


def entry(
    doc: Doc,
    bib: bibtexparser.model.Entry,
    homepages: None | dict[str, str],
) -> None:
    """Format an `entry` as HTML."""
    klass = ["paper"]
    match bib.entry_type:
        case "article":
            klass += ["journal"]
        case "inproceedings":
            klass += ["conference"]
        case _:
            klass += [bib.entry_type]

    with doc.tag("li", id=bib.key, klass=" ".join(klass)):
        _isodate, fmtdate, yr = parse_date(bib)

        authors(doc, bib, homepages)
        year(doc, yr)

        title(doc, bib)

        venue(doc, bib)
        publisher(doc, bib)
        if bib.entry_type != "unpublished":
            doc.text(". ")

        date(doc, fmtdate)
        note(doc, bib)
        doi(doc, bib)
        url(doc, bib)


def parse(content: str, sort: bool) -> list[bibtexparser.model.Entry]:
    """Parse some content, returning (possibly sorted) library of entries."""
    library = bibtexparser.parse_string(
        content,
        append_middleware=[
            mw.MonthAbbreviationMiddleware(),
            mw.SeparateCoAuthors(),
            mw.SplitNameParts(),
        ],
    )

    stats = {
        "blocks": len(library.blocks),
        "entries": len(library.entries),
        "comments": len(library.comments),
        "strings": len(library.strings),
        "preamble": len(library.preambles),
        "failures": len(library.failed_blocks),
    }
    log.info(f"{stats=}")

    if len(library.failed_blocks) > 0:
        for failure in library.failed_blocks:
            log.error(f"{failure.start_line}({failure.duplicate_keys}) {failure.raw}")

    return (
        sorted(library.entries, key=lambda e: parse_date(e)[0], reverse=True)
        if sort
        else library.entries
    )


def header(section: str) -> str:
    """Provide header with date/time and section name as a BibTeX comment."""
    dt = datetime.datetime.now().astimezone().isoformat()
    return f"%%comment{{datetime={{{dt}}}, section={{{section}}}}}"


class RemoveIntEnclosures(BlockMiddleware):
    def __init__(
        self,
    ):
        super().__init__()

    # def transform(self, library, *args, **kwargs):
    #     log.debug(f"transform")
    #     return library

    @override
    def transform_entry(self, entry, *args, **kwargs):
        log.debug(f"transform_entry: {entry.get('month').value}")
        return entry

    # def transform_string(self, string, *args, **kwargs):
    #     log.debug(f"transform_string: {string}")
    #     return string


@click.command(
    context_settings={"show_default": True, "ignore_unknown_options": True},
)
@click.argument("inputs", nargs=-1, type=click.File("r"))
@click.option("--debug", default=False, is_flag=True)
@click.option("--html", default=False, is_flag=True, help="Output HTML.")
@click.option("--sort/--no-sort", default=True, help="Sort entries.")
@click.option(
    "--homepages",
    "homepagesf",
    type=click.Path(exists=True, dir_okay=False, path_type=Path),
    help="Author-Homepage mapping (JSON dictionary)",
)
@click.option(
    "--section", default="", type=str, help="Section heading for HTML output."
)
@click.option(
    "--strings",
    "stringsf",
    type=click.Path(exists=True, dir_okay=False, path_type=Path),
    help="Abbreviations mapping.",
)
def bibtox(
    inputs: tuple[TextIO, ...],
    debug: bool,
    html: bool,
    sort: bool,
    homepagesf: Path | None,
    section: str,
    stringsf: Path | None,
) -> None:
    """Process BibTeX/BibLaTeX input file(s).

    Sort entries if requested. Output to HTML and/or BibTeX.
    """
    if debug:
        log.setLevel(logging.DEBUG)

    # load config if there is only one input and it's a JSON file
    log.debug(f"inputs={[i.name for i in inputs]}")
    config = (
        json.load(inputs[0])
        if len(inputs) == 1 and inputs[0].name.endswith(".json")
        else None
    )
    log.debug(f"{config=}")

    # load {author:homepages}, preferring command line option to config file
    if not homepagesf:
        homepagesf = Path(config.get("homepages")) if config else None
    log.debug(f"{homepagesf=}")

    homepages = {}
    if homepagesf:
        with homepagesf.open("r") as f:
            homepages = json.load(f)

    log.debug(f"{homepages=}")

    # load BibTeX abbreviation strings
    if not stringsf:
        stringsf = Path(config.get("strings")) if config else None

    strings = ""
    if stringsf:
        with stringsf.open("r") as f:
            strings = f.read()

    log.debug(f"{strings=}")

    # process sections
    if config and "sections" in config:
        items = {(k, [Path(v) for v in vs]) for k, vs in config["sections"].items()}
    else:
        items = {(section, inputs)}

    log.debug(f"{items=}")

    sections = []
    for section, filenames in items:
        log.info(f"{section=} {filenames=}")
        content = ""
        for filename in filenames:
            content += filename.read()

        entries = parse(strings + content, sort)
        sections.append((section, entries))

    log.debug(f"{sections=}")

    # output HTML or (default) BibTeX
    if html:
        doc = Doc()
        doc.text("{{dummy}}\n")
        for section, entries in sections:
            with doc.tag("section", klass="papers"):
                doc.text(section)
            with doc.tag("ol", "reversed", klass="papers"):
                for e in entries:
                    entry(doc, e, homepages)
        print(indent(doc.getvalue()))

    else:
        bf = bibtexparser.BibtexFormat()
        bf.value_column = "auto"
        bf.indent = "  "

        for section, entries in sections:
            print(f"{header(section)}\n")
            lib = bibtexparser.Library(blocks=entries)
            mws = [
                mw.MergeNameParts(allow_inplace_modification=True),
                mw.MergeCoAuthors(allow_inplace_modification=True),
                RemoveIntEnclosures(),
            ]
            bs = bibtexparser.write_string(
                lib,
                prepend_middleware=mws,
                bibtex_format=bf,
            )
            print(bs.strip())


if __name__ == "__main__":
    bibtox()
